#!/usr/bin/python3
import argparse
import shutil
import re
import random
from pathlib import Path


PROG_NAME = 'cconvert'


def error(msg):
    print_msg(f'error: {msg}')
    exit(1)


def print_msg(msg):
    print(f'{PROG_NAME}: {msg}')


def get_string_from_file(path):
    with path.open() as f:
        string = ''
        for line in f:
            string += line

    return string


def save(string, path):
    with path.open(mode='w') as f:
        f.write(string)
    

def replace(string, pattern, repl):
    return re.sub(pattern, repl, string, flags=re.DOTALL)


def copy_files(src_path, dest_path):
    FIRMWARE_PATH = src_path / Path('firmware')
    FILES = [
        (FIRMWARE_PATH / 'myproject.cpp', ''),
        (FIRMWARE_PATH / 'myproject.h', ''),
        (FIRMWARE_PATH / 'defines.h', ''),
        (FIRMWARE_PATH / 'parameters.h', ''),
        (FIRMWARE_PATH / 'weights', 'weights'),
        (None, 'tb_data'),
    ]

    for path, dest_dir in FILES:
        if path is None:
            (dest_path / dest_dir).mkdir()
        elif path.is_dir():
            shutil.copytree(path, dest_path / dest_dir)
        else:
            shutil.copy2(path, dest_path / dest_dir)


def replace_vivado(dest_path):
    # Process myproject.cpp
    myproject_path = dest_path / 'myproject.cpp'
    myproject = get_string_from_file(myproject_path)
    myproject = replace(myproject, r'#pragma', '//#pragma')
    save(myproject, myproject_path)

    # Process myproject.h
    myproject_h_path = dest_path / 'myproject.h'
    myproject_h = get_string_from_file(myproject_h_path)
    myproject_h = replace(myproject_h, r'ap_(.*?)\.h', r'ac_\1.h')
    save(myproject_h, myproject_h_path)

    # Process defines.h
    defines_path = dest_path / 'defines.h'
    defines = get_string_from_file(defines_path)
    defines = replace(defines, r'ap_(.*?)\.h', r'ac_\1.h')
    defines = replace(defines, r'ap_fixed<(\d+[, ]+\d+)(.*?)>',
                      r'ac_fixed<\1,true\2>')
    defines = replace(defines, r'ap_ufixed<(\d+[, ]+\d+)(.*?)>',
                      r'ac_fixed<\1,false\2>')
    defines = replace(defines, r'ap_int<(\d+)(.*?)>', r'ac_int<\1,true\2>')
    defines = replace(defines, r'ap_uint<(\d+)(.*?)>', r'ac_int<\1,false\2>')
    defines = replace(defines, r'AP_', 'AC_')
    save(defines, defines_path)

    # Process parameters.h
    parameters_path = dest_path / 'parameters.h'
    parameters = get_string_from_file(parameters_path)
    parameters = replace(parameters, r'ap_(.*?)\.h', r'ac_\1.h')
    parameters = replace(parameters, r'ap_fixed<(\d+[, ]+\d+)(.*?)>',
                         r'ac_fixed<\1,true\2>')
    parameters = replace(parameters, r'ap_ufixed<(\d+[, ]+\d+)(.*?)>',
                         r'ac_fixed<\1,false\2>')
    parameters = replace(parameters, r'ap_int<(\d+)(.*?)>',
                         r'ac_int<\1,true\2>')
    parameters = replace(parameters, r'ap_uint<(\d+)(.*?)>',
                         r'ac_int<\1,false\2>')
    parameters = replace(parameters, r'AP_', 'AC_')
    save(parameters, parameters_path)


def generate_test_data(src_path, dest_path):
    # Obtain network input and output types
    test_path = src_path / 'myproject_test.cpp'
    test = get_string_from_file(test_path)
    regex_match = re.search(r'(\S+) .+;\s*nnet::copy_data.+;\s*(\S+) .+;', test)

    input_type = regex_match.group(1)
    output_type = regex_match.group(2)

    # Obtain the number of network inputs and outputs + the input bit width
    defines_path = src_path / 'firmware' / 'defines.h'
    defines = get_string_from_file(defines_path)
    regex_results = re.findall(r'#define N_.+? (\d+)', defines)
    
    input_num = int(regex_results[0])
    output_num = int(regex_results[-1])

    regex_match = re.search(r'typedef ap_.+<(\d+).*> ' + input_type + ';',
                            defines)
    input_bits = int(regex_match.group(1))
    
    # Generate input data
    input_path = dest_path / 'tb_data' / 'tb_input_features.dat'
    with input_path.open(mode='w') as inputs:
        sets = 20
    
        for _ in range(sets):
            input_list = []
    
            for _ in range(input_num):
                bits = input_bits
                ints = []

                while bits > 0:
                    ints = [random.getrandbits(min(bits, 32))] + ints
                    bits -= 32
        
                input_list.append(' '.join(map(str, ints)))

            inputs.write(';'.join(input_list) + '\n')

    # Generate expected data
    test_template_path = \
        Path(__file__).parent.parent / 'templates' / 'myproject_test.cpp'
    test_template = get_string_from_file(test_template_path)
    test_template = test_template.replace('{{N_INPUT}}', str(input_num))
    test_template = test_template.replace('{{N_OUTPUT}}', str(output_num))
    test_template = test_template.replace('{{INPUT_TYPE}}', input_type)
    test_template = test_template.replace('{{OUTPUT_TYPE}}', output_type)

    old_test_path = test_path.rename(src_path / 'myproject_test.cpp.old')
    save(test_template, test_path)


def generate_exp_table(dest_path):
    pass


def generate_invert_table(dest_path):
    pass


def run(src, dest):
    src_path = Path(src)
    dest_path = Path(dest)

    try:
        if not src_path.exists():
            error('the source directory does not exist')

        if not dest_path.exists():
            dest_path.mkdir(parents=True)

        # Step 1: Copy the files
        copy_files(src_path, dest_path)

        # Step 2: Replace Vivado-specific parts with Catapult ones
        replace_vivado(dest_path)

        # Step 3: Generate test data
        generate_test_data(src_path, dest_path)
    
        # Step 4: Generate exp_table.h and invert_table.h
        generate_exp_table(dest_path)
        generate_invert_table(dest_path)
    
        # Done!
        print_msg('the specified hls4ml Vivado HLS project has been converted '
                  'successfully!')
    except Exception as ex:
        shutil.rmtree(dest_path, ignore_errors=True)
        raise ex


if __name__ == '__main__':
    parser = argparse.ArgumentParser(prog=PROG_NAME,
                                     description='Convert an hls4ml Vivado HLS '
                                     'project to its Catapult equivalent.')
    parser.add_argument('src', metavar='SOURCE',
                        type=str, help='the path to an hls4ml project directory')
    parser.add_argument('dest', metavar='DESTINATION',
                        type=str, help='the path to a directory where the '
                        'Catapult project should be exported to (the directory '
                        'will be created if it does not exist)')

    args = parser.parse_args()
    run(args.src, args.dest)
